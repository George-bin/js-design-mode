# 观察者模式
定义了对象间一（被观察者）对多（观察者）的依赖关系，当目标对象Subject的状态发生改变时，所有依赖它的对象Observer都会得到通知。

# 目标对象subject（被观察者-发布者）
1. 添加Observer => addSub
2. 删除Observer => removeSub
3. 通知Observer => notify


# 观察者对象Observer（观察者-订阅者）
1. 接受subject状态变更通知并处理

# 被观察者和观察者之间的关系
目标对象和观察者是直接联系在一起的，这种模式下目标对象类似一个发布者，它让添加进来的所有观察者都执行update函数，而观察者类似于一个订阅者。

# 基本步骤如下
1. 观察者需要订阅（监听）被观察者（发布者）的状态，会调用被观察者（发布者）的api将自己添加到被观察者（发布者）的订阅者列表中；
2. 当被观察者（发布者）的状态发生改变时，会遍历它的订阅者列表调用每个观察者（订阅者）的update（执行函数）触发相应的行为；
3. 当观察者（订阅者）不需要订阅（监听）观察者的状态时，会主动调用被观察者的api退出被观察者（发布者）的订阅者列表；
4. 后续被观察者（发布者）的状态发生改变时，不会再通知已退出的观察者（订阅者）。

# 案例一：DOM点击事件监听
document.addEventListener('click', 事件1)
document.addEventListener('click', 事件2)
document.removeEventListener('click', 事件2)

被观察对象（发布者）：document
观察对象（订阅者）：事件1、事件2
添加observer：addEventListener
删除observer：removeEventListener
通知Observer：用户click事件

可以看出，被观察者（发布者）和观察者（订阅者）二者是紧密联系在一起的，观察者直接依赖于被观察者状态的改变，然后触发观察者们各自的行为。
注意：观察者（订阅者）的订阅和取消订阅的动作都是主动触发的，被观察者只是在状态变更时通知它的订阅者列表中的订阅者。